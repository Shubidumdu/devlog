---
title: Core Web Vitals
desc: 웹 성능 지표로서 Core Web Vitals이 갖는 의미와 이에 대한 개선/측정, 그리고 이를 갖출 때 얻는 이점에 대해 살펴봅니다.
createdAt: '2023-12-12'
image: 
tags:
    - Web
    - Browser
---

## Web Vitals

Web Vital은 웹에서의 우수한 경험을 제공하기 위해 필수적인 품질을 측정하기 위해 Google로부터 제안된 몇 가지 지표들입니다. 
이번 글에서 다루고자 하는 **Core Web Vitals**은 이러한 Web Vital 중에서도 가장 중요한 지표들을 의미합니다.

## Core Web Vitals

Core Web Vitals은 다음과 같은 지표들을 포함하며, 각각이 측정하고자 하는 항목을 대략적으로 살펴보면 다음과 같습니다.

- **Largest Contentful Paint (LCP)**: *로딩*(loading)을 측정하는 지표
- **First Input Delay (FID)**: *인터랙션*(interactivity)을 측정하는 지표
- **Cumulative Layout Shift (CLS)**: *시각적 안정성*(visual stability)을 측정하는 지표

![Alt text](image.png)

Core Web Vital은 지속적으로 연구 및 개선, 추가되고 있는 지표들이기 때문에, 훗날에는 위 3가지가 아닐 가능성이 있습니다.
대표적으로, 현재는 INP(Interaction to Next Paint)라는 지표가, 위의 FID를 대체하기 위한 측정 항목으로 제안되고 있으며, 이는 24년 3월로 예정되어 있습니다.
INP에 대한 내용 역시 아래의 섹션에서 살펴볼 계획입니다.

이제 각 지표에 대해 보다 상세하게 살펴보겠습니다.

### Largest Contentful Paint (LCP)

![Alt text](image-1.png)

**LCP**는 사용자가 웹 페이지를 처음으로 이동한 시점을 기준으로, **가장 큰 이미지 또는 텍스트 블록이 렌더링되기까지 걸리는 시간을 측정**하는 지표입니다.

이전에는 페이지 로딩 성능에 대한 측정을 할 때, `load`, `DOMContentLoaded`와 같은 이벤트를 사용했으나, 이것이 "사용자의 화면에 무엇인가 표시됨"을 의미하는 것과는 거리가 멀었습니다.

한편, 이와 유사한 FCP(First Contentful Paint) 역시 사용자 중심의 로딩 성능 측정을 위한 것이지만, 이 경우 페이지 로드 시 실제 컨텐츠와 관련없이 등장하는 **스피너** 또는 **스플래시 스크린**이 활용되는 웹 사이트의 경우 FCP가 사용자와 큰 관련이 있다고 보기 어렵다는 문제가 있습니다.

![Alt text](image-2.png)

**좋은 LCP 점수란**, 해당 최대 컨텐츠의 렌더링 시간이 **2.5초** 이하인 경우를 의미합니다. 그 이상이 되는 경우, 개선이 필요한 것으로 여기고, 만약 **4초** 이상이 된다면 나쁜 LCP 점수를 갖는다고 보고 있습니다.

#### 그럼, Largest Content를 어떻게 정하나요?

실제 [**Largest Contentful Paint API**](https://w3c.github.io/largest-contentful-paint/)에 정의된 바에 따르면 Largest Content로 간주되는 요소는 아래와 같습니다.

- `<img>` 요소
- `<svg>` 요소 내 `<image>` 요소
- 포스터 이미지가 있는 `<video>` 요소
- `url()` 함수를 통해 로드된 배경 이미지가 있는 요소(CSS 그라데이션과 반대)
- 텍스트 노드 또는 기타 인라인 수준 텍스트 요소 하위 요소를 포함하는 블록 수준 요소.
- `<video>` 요소 자동재생을 위해 그린 첫 번째 프레임 (2023년 8월 기준)
- 애니메이션 GIF와 같은 애니메이션 이미지 형식의 첫 번째 프레임 (2023년 8월 기준)

이처럼 "가장 큰 컨텐츠"로 간주되는 것에 대한 범위가 제한적인 것은 그 측정 작업 자체를 간단하게 유지하기 위함입니다. 향후 연구의 진행에 따라 점차 추가되는 요소가 있을 수 있습니다.

또, 단순히 요소를 고려하는 것 이상으로, 사용자에게 "컨텐츠가 없음"으로 인식될 수 있는 특정 요소들은 제외하기 위해 특정한 휴리스틱(heuristic)을 적용하고 있습니다. 이는 브라우저마다 차이가 있을 수 있는데, Chromium 기반의 브라우저에는 다음의 휴리스틱들이 적용됩니다.

- 사용자에게 보이지 않는, `opacity`가 `0`인 요소
- 전체 뷰포트 영역을 덮는 요소 (컨텐츠가 아닌 배경으로 간주될만한 요소)
- 페이지의 실제 컨텐츠를 반영하지 않는, 낮은 엔트로피를 지닌 placeholder 이미지

브라우저들은 자체적으로 "가장 큰 컨텐츠 요소"가 무엇인지 정확히 판단하기 위해 이러한 휴리스틱들을 지속적으로 개선하고 있습니다.

#### "요소의 크기"는 어떤 기준으로 정해지나요?

LCP를 위해 리포트되는 요소의 크기란, 일반적으로 "뷰포트 내에서 이용자에게 보여지는 크기"를 의미합니다. 이는 다시 말해, 

1. 요소가 뷰포트 외부로 확장되거나, `overflow`로 인해 요소 일부가 잘리거나 보이지않는 경우는 여기서 말하는 "크기"에 포함되지 않습니다.

2. 텍스트의 경우 전체 텍스트 노드를 감싸는 가장 작은 블록 수준 요소의 크기만 고려됩니다.

3. 모든 요소에서, CSS를 통해 적용된 `margin`, `padding`, `border`는 고려되지 않습니다.

#### LCP는 어느 시점에 리포트되나요?

여러 단계에 거쳐 로드가 진행되는 웹 페이지의 경우, 가장 큰 요소가 변경되는 일이 충분히 발생할 수 있습니다.

이러한 상황에 대응하기 위해, 브라우저는 가장 큰 것으로 인식되는 요소가 변경될 때마다 `largest-contentful-paint` 타입의 [`PerformanceEntry`](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceEntry)를 디스패치합니다. 

예를 들어, 최초에 헤더 텍스트에 해당하는 `<h1>` 요소가 `largest-contenful-paint` 엔트리로 디스패치되었더라도, 이후에 뷰포트 내에 가장 큰 요소가 변경되어 새로운 `<img>` 요소가 가장 큰 요소로 인식되면, `<img>` 요소에 대한 `largest-contentful-paint` 엔트리가 새로 디스패치됩니다.

그렇기 때문에 만약 분석을 위해서 JS 상으로 `PerformanceEntry` 정보를 수집하고자 한다면, 가장 마지막에 전달된 `PerformanceEntry`만을 분석 서비스에 보고하여 다루도록 해야합니다.

브라우저는 이용자가 페이지에 대해 어떤 상호작용을 하는 시점에 LCP 리포트를 중지합니다. (ex. 클릭, 스크롤 등) 이는 이용자의 인터랙션에 의해 페이지에 보여지는 내용이 변경될 수 있기 때문입니다.

> 유의점: 요소는 렌더링되어 실제로 사용자에게 표시되는 경우에만 가장 큰 요소로 인식됩니다. 아직 로드되지 않은 이미지는 렌더링된 것으로 간주하지 않고, 웹 폰트를 사용할 경우에 발생하는 [폰트 블록](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/font-display#The_font_display_timeline) 시점에도 가장 큰 요소로 인식되지 않습니다.
>
> 또한, 이미 리포트된 요소의 크기나 위치를 변경하더라도 새로운 LCP가 디스패치되지는 않습니다. 뷰포트 내에 있는 요소의 초기 크기와 위치만 고려됩니다.

![Alt text](image-4.png)

![Alt text](image-5.png)

#### `Timing-Allow-Origin` 헤더

보안 상의 이유로, 교차 출처 이미지 내에 [`Timing-Allow-Origin`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Timing-Allow-Origin) 헤더가 존재하지 않는 경우에는 이미지의 렌더링 시간을 측정할 수 없습니다. 이 경우, LCP는 대신에 해당 이미지의 로드 시간을 측정합니다.

여기서 말하는 로드 시간과 렌더링 시간은 비슷한 듯 의미하는 바가 다릅니다. 이미지의 로드 시간은 이미지가 브라우저에 의해 다운로드되는 시간을 의미하고, 렌더링 시간은 로드된 이미지가 브라우저에 의해 실제로 렌더링되어 이용자에게 노출되는 시간을 의미합니다.

이 경우, LCP가 FCP(First Contentful Paint)보다 빠르게 보고되는, 실질적으로는 불가능한 상황이 발생할 수 있습니다. 이는 실제 지표가 아니며, 앞서 말한 헤더에 의한 보안 상의 제한으로 발생하는 문제입니다.

즉, LCP 측정의 정확도를 높이기 위해서는 가능한 교차 출처 컨텐츠에는 `Timing-Allow-Origin` 헤더를 설정해두는 것이 좋습니다.

## 참조
- https://web.dev/articles/user-centric-performance-metrics?hl=ko

---